# JavaScript闭包的学习总结

### 什么是闭包

* 闭包是指有权访问另一个函数作用域中的变量的函数。因此，闭包的最大用处就是防止对全局作用域的影响和污染。

### JS中变量的作用域

* 要掌握JS的闭包，首先要知道JS特殊的变量作用域。变量的作用域，无非就是全局变量和局部变量两种。而在JS中，函数内部可以直接拿到全局变量。

* 下面给出几个代码示例

```
window.onload = function () {
	var temp = 666;
	function f() {
		alert(temp);
	}
	f();    //666
}
```

显然，函数内部可以直接拿到全局变量。

```
window.onload = function () {
	function f() {
    	var temp = 666;
    }
    alert(temp);    //控制台报错：temp is not defined
}
```

而在全局下，则不能拿到函数内部的变量。

```
window.onload = function () {
	function f() {
    	temp = 666;
    }
    f();
    alert(temp);    //666
}
```

注意：如果在函数内部声明变量的时候没有使用var，则是声明了一个全局变量。

### 一个简单的闭包

```
window.onload = function () {
	function f1() {
		var temp = 666;
            
		function f2() {
			alert(temp);
		}

		return f2;
	}
	var re = f1();
	re();    //666
}
```

在上面的代码中，实现了一个简单的闭包，函数f2包含在函数f1中，如此f1中的所有变量对f2都是可见的。（这里涉及到JS的“链式作用域“结构特点：子对象会一级一级向上寻找所有父对象的变量。因此，父对象的变量对子对象都是可见的）函数f1的返回值是函数f2，而f2在f1内部，能够访问到局部变量temp，当f2作为f1的返回值赋值给全局的变量时，在全局作用域访问到了temp，这就是闭包。

### 闭包的原理

* 每个函数都有自己的执行环境，当一个函数被执行时，它的执行环境就会被推入环境栈，其活动对象（存储环境中定义的变量及函数）加入作用域链中，一旦函数执行完，栈将其环境弹出，活动对象被销毁。对于上面的例子来说，f1执行完之后将返回f2给了re，f1的执行环境从环境栈弹出，控制权交给全局环境，f2的活动对象理应被销毁。但此时f2已经存储在全局活动对象中了，同时f2需要访问temp，所以f1的活动对象没有被销毁，即使f1执行完毕，f1的活动对象依然存在于作用域链中，只有当re被销毁，f1的活动对象才会彻底释放。

### 闭包的用途

* 闭包最大的用处有两个：一个是可以拿到函数内部的变量，另一个就是可以延长这些变量的生存时间。

* 示例代码

```
window.onload = function () {
	function f1() {
		var n = 999;
		nAdd = function(){n += 1}
		function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;	
　　}
　　
	var result = f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
}
```

* 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

### 使用闭包时的注意点

* 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

* 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

